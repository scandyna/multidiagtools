/****************************************************************************
 **
 ** Copyright (C) 2011-2018 Philippe Steinmann.
 **
 ** This file is part of multiDiagTools library.
 **
 ** multiDiagTools is free software: you can redistribute it and/or modify
 ** it under the terms of the GNU Lesser General Public License as published by
 ** the Free Software Foundation, either version 3 of the License, or
 ** (at your option) any later version.
 **
 ** multiDiagTools is distributed in the hope that it will be useful,
 ** but WITHOUT ANY WARRANTY; without even the implied warranty of
 ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ** GNU Lesser General Public License for more details.
 **
 ** You should have received a copy of the GNU Lesser General Public License
 ** along with multiDiagTools.  If not, see <http://www.gnu.org/licenses/>.
 **
 ****************************************************************************/

/*! \page libs_Entity Entity
 *
 * \todo Explain 2 approches:
 *   - Accept to depend on Entity library in business model and use validadtors, item delegates, ... that uses Entiy attributes (central eay to give some common constraints)
 *   - Depend on Entity in only some parts
 *   - For repositories:
 *    -> Inherit from AbstractCachedRepository or AbstractRepository
 *    -> Create a base class that Inherits from AbstractCachedRepository or AbstractRepository
 *       (which will be to implement once Mdt::[Entity|Repository] is no longer usable for the project)
 *   - Note: Qt will allways remain a dependency (QString, QVariant, ItemModels, signals/slots)
 *
 * In this library, the concept of a entity is a thing of interest
 *  in the application, like a Article, a Person, etc..
 *
 * \note This library does not implement the
 *       [entity component system](https://en.wikipedia.org/wiki/Entity%E2%80%93component%E2%80%93system)
 *
 * A entity can be stored (for example to a SQL database),
 *  which requires some kind of reflection.
 *
 * \section introduction Introduction
 *
 * Qt offers some runtime introspection with the QMetaObject.
 *  A idea could be to create a entity as a subclass of QObject,
 *  and define properties:
 * \code
 * class Person : public QObject
 * {
 *  Q_OBJECT
 *  Q_PROPERTY(qlonglong id READ id WRITE setId);
 *  public:
 *   qlonglong id() const;
 *   void setId(qlonglong id);
 * };
 * \endcode
 * The first problem with a QObject subclass is
 *  that it is not a value class: it cannot be copied.
 *  The second problem is that properties are runtime only.
 *  For example, having a expression like:
 * \code
 *  client.id == 25
 * \endcode
 *  is not possible.
 *
 * There are several C++ libraries available for compile time reflection:
 * - [Boost Mpl](http://www.boost.org/doc/libs/1_66_0/libs/mpl/doc/index.html)
 * - [Boost Hana](http://www.boost.org/doc/libs/1_66_0/libs/hana/doc/html/index.html)
 * - [iguana](https://github.com/qicosmos/iguana)
 * - Probably many more
 *
 * Those libraries are fully compile time, as far as I know.
 *  Mdt::Entity keepts a part of its classes usable at runtime.
 *  This can be usefull, for example, to create dynamicly editable entities.
 *
 * \section createAentity Create a entity
 *
 *  The first step is to create create a data struct, which will contain all attributes of the entity.
 *   Then, the entity can be created using MDT_ENTITY_DEF() .
 *
 *  The next step is to create a value class using Mdt::Entity::DataTemplate .
 *
 *  Starting from here, it is possible to present a list on the entities in the Qt model/view, using one of:
 *   - Mdt::Entity::ReadOnlyTableModel
 *   - Mdt::Entity::EditableTableModel
 *   - Mdt::Entity::RowResizableTableModel
 *
 *  %Relation between entities can be defined using Mdt::Entity::Relation .
 *
 * \subsection entityDataStructTypes Note on types in data struct
 *
 *  As mentionned by MDT_ENTITY_DEF() , a entity is created starting from a data struct:
 *  \code
 *  struct PersonDataStruct
 *  {
 *    qlonglong id = 0;
 *    QString firstName
 *  };
 *  \endcode
 *  In the data struct, only types that are natively handled by QVariant should be used.
 *  For example, prefer qlonglong instead of long long .
 *
 *  It is alos common to use custom types (that maybe wraps a primitive type) for type safety.
 *  As long as it is declared to the QMetaType using Q_DECLARE_METATYPE() ,it could be put into the data struct.
 *  Doing so will later cause problems with APIs that are based on QVariant (like item models),
 *  because converting it from/to Qt known types will not automatically be possible.
 *  To avoid to mutch boiler plate code, QVariant natively supported types should be used whenever possible.
 *
 *  To enforce type safety, custom type can be used.
 *  A example could be a unique identifier, based on Mdt::Entity::IntegralUniqueIdTemplate :
 *  \code
 *  class PersonId : public Mdt::Entity::IntegralUniqueIdTemplate<>
 *  {
 *   public:
 *
 *    using IntegralUniqueIdTemplate<>::IntegralUniqueIdTemplate;
 *  };
 *  \endcode
 *  This class should not be put into the data struct (PersonDataStruct),
 *  but exposed by the data class:
 *  \code
 *  class PersonData : public Mdt::Entity::DataTemplate<PersonEntity>
 *  {
 *   public:
 *
 *    void setPersonId(PersonId id)
 *    {
 *      dataStruct().id = id.value();
 *    }
 *
 *    PersonId personeId() const
 *    {
 *      return PersonId( constDataStruct().id );
 *    }
 *  };
 *  \endcode
 *
 *  \section entityRepository Entity repository
 *
 *  \code
 *  class AbstractPersonRepository : public Mdt::Entity::AbstractCachedRepository<PersonData>
 *  {
 *  };
 *
 *  using PersonRepository = Mdt::Entity::RepositoryHandle<AbstractPersonRepository>;
 *  using PersonRepositoryStlTableProxy = Mdt::Entity::CachedRepositoryStlTableProxy<AbstractPersonRepository>;
 *  \endcode
 *
 *  \code
 *  class EditPersonTableModel : public Mdt::Entity::EditableTableModel<PersonRepositoryStlTableProxy>
 *  {
 *   Q_OBJECT
 *
 *   public:
 *
 *    using ParentClass = Mdt::Entity::EditableTableModel<PersonRepositoryStlTableProxy>;
 *    using ParentClass::ParentClass;
 *  };
 *  \endcode
 *
 *  \code
 *  class SqlPersonRepository : public AbstractPersonRepository
 *  {
 *  };
 *  \endcode
 *
 *  \code
 *  auto personRepository = PersonRepository::make<SqlPersonRepository>();
 *  EditPersonTableModel model:
 *  model.table().setRepository(personRepository);
 *  \endcode
 *
 *  \sa the Mdt::Entity namespace
 */

namespace Mdt{

  /*! \brief Some helpers to create a entity
   */
  namespace Entity{
  }

}
