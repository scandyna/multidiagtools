<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libusb: Caveats</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libusb</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Caveats </div>  </div>
</div>
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="devresets"></a>
Device resets</h2>
<p>The <a class="el" href="group__dev.html#ga7321bd8dc28e9a20b411bf18e6d0e9aa" title="Perform a USB port reset to reinitialize a device.">libusb_reset_device()</a> function allows you to reset a device. If your program has to call such a function, it should obviously be aware that the reset will cause device state to change (e.g. register values may be reset).</p>
<p>The problem is that any other program could reset the device your program is working with, at any time. libusb does not offer a mechanism to inform you when this has happened, so if someone else resets your device it will not be clear to your own program why the device state has changed.</p>
<p>Ultimately, this is a limitation of writing drivers in userspace. Separation from the USB stack in the underlying kernel makes it difficult for the operating system to deliver such notifications to your program. The Linux kernel USB stack allows such reset notifications to be delivered to in-kernel USB drivers, but it is not clear how such notifications could be delivered to second-class drivers that live in userspace.</p>
<h2><a class="anchor" id="blockonly"></a>
Blocking-only functionality</h2>
<p>The functionality listed below is only available through synchronous, blocking functions. There are no asynchronous/non-blocking alternatives, and no clear ways of implementing these.</p>
<ul>
<li>Configuration activation (<a class="el" href="group__dev.html#ga186593ecae576dad6cd9679f45a2aa43" title="Set the active configuration for a device.">libusb_set_configuration()</a>)</li>
<li>Interface/alternate setting activation (<a class="el" href="group__dev.html#ga3047fea29830a56524388fd423068b53" title="Activate an alternate setting for an interface.">libusb_set_interface_alt_setting()</a>)</li>
<li>Releasing of interfaces (<a class="el" href="group__dev.html#gaf0d053dd23420c4daec89c06da04abe4" title="Release an interface previously claimed with libusb_claim_interface().">libusb_release_interface()</a>)</li>
<li>Clearing of halt/stall condition (<a class="el" href="group__dev.html#ga5b321176ce7f18cfec369dd3ab7d431e" title="Clear the halt/stall condition for an endpoint.">libusb_clear_halt()</a>)</li>
<li>Device resets (<a class="el" href="group__dev.html#ga7321bd8dc28e9a20b411bf18e6d0e9aa" title="Perform a USB port reset to reinitialize a device.">libusb_reset_device()</a>)</li>
</ul>
<h2><a class="anchor" id="nohotplug"></a>
No hotplugging</h2>
<p>libusb-1.0 lacks functionality for providing notifications of when devices are added or removed. This functionality is planned to be implemented for libusb-1.1.</p>
<p>That said, there is basic disconnection handling for open device handles:</p>
<ul>
<li>If there are ongoing transfers, libusb's handle_events loop will detect disconnections and complete ongoing transfers with the LIBUSB_TRANSFER_NO_DEVICE status code.</li>
<li>Many functions such as <a class="el" href="group__dev.html#ga186593ecae576dad6cd9679f45a2aa43" title="Set the active configuration for a device.">libusb_set_configuration()</a> return the special LIBUSB_ERROR_NO_DEVICE error code when the device has been disconnected.</li>
</ul>
<h2><a class="anchor" id="configsel"></a>
Configuration selection and handling</h2>
<p>When libusb presents a device handle to an application, there is a chance that the corresponding device may be in unconfigured state. For devices with multiple configurations, there is also a chance that the configuration currently selected is not the one that the application wants to use.</p>
<p>The obvious solution is to add a call to <a class="el" href="group__dev.html#ga186593ecae576dad6cd9679f45a2aa43" title="Set the active configuration for a device.">libusb_set_configuration()</a> early on during your device initialization routines, but there are caveats to be aware of:</p>
<ol type="1">
<li>If the device is already in the desired configuration, calling <a class="el" href="group__dev.html#ga186593ecae576dad6cd9679f45a2aa43" title="Set the active configuration for a device.">libusb_set_configuration()</a> using the same configuration value will cause a lightweight device reset. This may not be desirable behaviour.</li>
<li>libusb will be unable to change configuration if the device is in another configuration and other programs or drivers have claimed interfaces under that configuration.</li>
<li>In the case where the desired configuration is already active, libusb may not even be able to perform a lightweight device reset. For example, take my USB keyboard with fingerprint reader: I'm interested in driving the fingerprint reader interface through libusb, but the kernel's USB-HID driver will almost always have claimed the keyboard interface. Because the kernel has claimed an interface, it is not even possible to perform the lightweight device reset, so <a class="el" href="group__dev.html#ga186593ecae576dad6cd9679f45a2aa43" title="Set the active configuration for a device.">libusb_set_configuration()</a> will fail. (Luckily the device in question only has a single configuration.)</li>
</ol>
<p>One solution to some of the above problems is to consider the currently active configuration. If the configuration we want is already active, then we don't have to select any configuration: </p>
<div class="fragment"><pre class="fragment">cfg = <a class="code" href="group__dev.html#ga6fdf904b6d53279da278b3556e51273c" title="Determine the bConfigurationValue of the currently active configuration.">libusb_get_configuration</a>(dev);
<span class="keywordflow">if</span> (cfg != desired)
    <a class="code" href="group__dev.html#ga186593ecae576dad6cd9679f45a2aa43" title="Set the active configuration for a device.">libusb_set_configuration</a>(dev, desired);
</pre></div><p>This is probably suitable for most scenarios, but is inherently racy: another application or driver may change the selected configuration <em>after</em> the <a class="el" href="group__dev.html#ga6fdf904b6d53279da278b3556e51273c" title="Determine the bConfigurationValue of the currently active configuration.">libusb_get_configuration()</a> call.</p>
<p>Even in cases where <a class="el" href="group__dev.html#ga186593ecae576dad6cd9679f45a2aa43" title="Set the active configuration for a device.">libusb_set_configuration()</a> succeeds, consider that other applications or drivers may change configuration after your application calls <a class="el" href="group__dev.html#ga186593ecae576dad6cd9679f45a2aa43" title="Set the active configuration for a device.">libusb_set_configuration()</a>.</p>
<p>One possible way to lock your device into a specific configuration is as follows:</p>
<ol type="1">
<li>Set the desired configuration (or use the logic above to realise that it is already in the desired configuration)</li>
<li>Claim the interface that you wish to use</li>
<li>Check that the currently active configuration is the one that you want to use.</li>
</ol>
<p>The above method works because once an interface is claimed, no application or driver is able to select another configuration.</p>
<h2><a class="anchor" id="earlycomp"></a>
Early transfer completion</h2>
<p>NOTE: This section is currently Linux-centric. I am not sure if any of these considerations apply to Darwin or other platforms.</p>
<p>When a transfer completes early (i.e. when less data is received/sent in any one packet than the transfer buffer allows for) then libusb is designed to terminate the transfer immediately, not transferring or receiving any more data unless other transfers have been queued by the user.</p>
<p>On legacy platforms, libusb is unable to do this in all situations. After the incomplete packet occurs, "surplus" data may be transferred. Prior to libusb v1.0.2, this information was lost (and for device-to-host transfers, the corresponding data was discarded). As of libusb v1.0.3, this information is kept (the data length of the transfer is updated) and, for device-to-host transfesr, any surplus data was added to the buffer. Still, this is not a nice solution because it loses the information about the end of the short packet, and the user probably wanted that surplus data to arrive in the next logical transfer.</p>
<p>A previous workaround was to only ever submit transfers of size 16kb or less.</p>
<p>As of libusb v1.0.4 and Linux v2.6.32, this is fixed. A technical explanation of this issue follows.</p>
<p>When you ask libusb to submit a bulk transfer larger than 16kb in size, libusb breaks it up into a number of smaller subtransfers. This is because the usbfs kernel interface only accepts transfers of up to 16kb in size. The subtransfers are submitted all at once so that the kernel can queue them at the hardware level, therefore maximizing bus throughput.</p>
<p>On legacy platforms, this caused problems when transfers completed early Upon this event, the kernel would terminate all further packets in that subtransfer (but not any following ones). libusb would note this event and immediately cancel any following subtransfers that had been queued, but often libusb was not fast enough, and the following subtransfers had started before libusb got around to cancelling them.</p>
<p>Thanks to an API extension to usbfs, this is fixed with recent kernel and libusb releases. The solution was to allow libusb to communicate to the kernel where boundaries occur between logical libusb-level transfers. When a short transfer (or other error) occurs, the kernel will cancel all the subtransfers until the boundary without allowing those transfers to start. </p>
</div></div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Feb 27 2012 17:16:53 for libusb by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
